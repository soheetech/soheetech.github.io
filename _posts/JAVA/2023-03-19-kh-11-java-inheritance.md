---
layout: post

category: JAVA
tag: Theory
title: "[KH/JAVA] 상속(Inheritance)"

date: 2023-03-08
last_modified_at: 2023-03-19
---

# 상속(Inheritance)
다른 클래스(부모 클래스)가 가지고 있는 멤버(필드, 메소드)들을 새로 작성할 클래스(자식 클래스)에서 직접 만들지 않고 상속을 받음으로써 새 클래스(자식 클래스)가 자신의 멤버처럼 사용할 수 있는 기능

- 부모 클래스와 자식 클래스 간의 관계
  + 상속을 주는 클래스 : 슈퍼, 베이스, 기반, 상위 또는 부모 클래스
  + 상속을 받는 클래스 : 서브, 파생, 하위 또는 자식 클래스
  + 서브 클래스는 슈퍼 클래스의 모든 특성을 상속받으며 추가적으로 자신만의 필드와 메소드를 정의할 수 있음
- 가장 중요한 객체지향 개념의 하나로 기존 클래스를 이용해 새로운 클래스를 정의하는 방법
- 프로그램 구조화를 위한 좋은 방법
- 자바에서는 단일 상속만 지원함


## 상속의 목적
- 클래스의 재사용
- 연관된 일련의 클래스들에 대한 공통적인 규약 정의

## 상속의 장점
- 보다 적은 양의 코드로 새로운 클래스 작성 가능
- 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이
- 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여

## 상속 방법과 표현식

```java
// class간의 상속 시 extends 키워드 사용

[접근제한자] class 클래스명 extends 클래스명{}
```

## 단일 상속과 다중 상속

### 단일 상속(Single Inheritance)
클래스간의 관계가 다중 상속보다 명확하고 신뢰성 있는 코드 작성

### 다중 상속(Multiple Inheritance)
- C++에서 가능한 기능
- 여러 클래스로부터 상속을 받으며 복합적인 기능을 가진 클래스를 쉽게 작성 가능
- 하지만 서로 다른 클래스로부터 상속 받은 멤버 간의 이름이 같은 경우 문제 발생

## 상속의 특징
- 모든 클래스는 `Object` 클래스의 후손
  + `Object` 클래스가 제공하는 메소드를 오버라이딩하여 메소드 재구현 가능
- 부모클래스의 생성자, 초기화 블록은 상속 안 됨
  + 자식 클래스 생성 시, 부모 클래스 생성자가 먼저 실행
  + 자식 클래스 생성자 안에서 부모 클래스 생성자 호출을 명시하고 싶으면 `super()` 활용
- 부모의 `private`멤버는 상속되지만 직접 접근 불가
  + 자식 객체 생성 시에 부모의 필드 값도 전달 받은 경우, 자식 생성자 안에서 부모의 `private` 필드에 직접 접근하여 대입 불가
  + `super()` 이용하여 전달받은 부모 필드 값을 부모 생성자 쪽으로 넘겨서 생성하거나 `setter`, `getter` 메소드를 이용하여 접근

## super()와 super.

### super()
- 부모 객체의 생성자를 호출하는 메소드
- 기본적으로 후손 생성자에 부모 생성자가 포함됨
- 후손 객체 생성 시에는 부모부터 생성이 되기 때문에 후손 클래스 생성자 안에는 부모 생성자를 호출하는 `super()`가 첫 줄에 존재
  + 부모 생성자가 가장 먼저 실행되어야 하기 때문에 명시적으로 작성 시에도 반드시 첫 줄에만 작성
  + 매개변수 있는 부모 생성자 호출은 `super(매개변수, 매개변수)`를 넣으면 됨

### super.
- 상속을 통한 자식 클래스 정의 시 해당 자식 클래스의 부모 객체를 가리키는 참조 변수
- 자식 클래스 내에서 부모 클래스 객체에 접근하여 필드나 메소드 호출시 사용

## 오버라이딩(Overriding)
≒ 덮어쓰기, 재정의, Over : 초과, 넘침, 상위, Riding : 탑승, 올라탐
<small>※ 오버라이딩과 오버로딩의 용어가 비슷하기 때문에 헷갈리지 않도록 주의</small>

- 자식 클래스가 상속 받은 부모 메소드를 재작성하는 것
- 부모가 제공하는 기능을 후손이 일부 고쳐 사용하겠다는 의미
- 자식 객체를 통한 실행 시 후손 것이 우선권을 가짐

### 오버라이딩 특징
- 메소드 헤드라인 위에 반드시 어노테이션(Annotation), `@Override` 표시
- 접근 제어자를 부모 것보다 같거나 넓은 범위로 변경 가능
- 부모 메소드의 예외처리 클래스 처리 범위보다 좁은 범위로 예외처리 클래스 수정 가능

### 오버라이딩 성립 조건
부모 클래스의 메소드와 자식 클래스의 메소드 비교

- 메소드 이름 동일
- 매개변수의 개수, 타입, 순서 동일
- `return` 타입 동일
- `private` 메소드 오버라이딩 불가

### 오버라이딩 vs 오버로딩

<div class="table-wrapper" markdown="block">

| 오버라이딩(Overriding) | 오버로딩(Overloading) |
| :-: | :-: |
| 하위 클래스에서 메소드 정의 | 같은 클래스에서 메소드 정의 |
| 메소드 이름 동일<br />매개변수 동일(개수, 타입, 순서)<br />리턴 타입 동일 | 메소드 이름 동일<br />매개변수 다름(개수, 타입, 순서)<br />리턴 타입 상관 없음 |
| 자식 메소드의 접근 범위가 부모 메소드의 접근 범위보다 넓거나 같아야 함 | 접근 제어자와 상관 없음 |
| 자식 메소드의 예외 수가 부모 메소드의 예외 수보다 적거나 범위가 좁아야 함 | 예외 처리와 상관 없음 |

</div>

## final 예약어

### final 클래스
상속이 불가능한 클래스

```java
public final class finalClass{}
```

### final 메소드
상속 시 오버라이딩이 불가능한 메소드

```java
public final void method() {}
```

## 대상에 따른 사용 가능한 제어자와 예약어

<div class="table-wrapper" markdown="block">

| 대상 | 사용 가능한 제어자/예약어 |
| :-: | :- |
| 클래스 | public, (default), final, abstract |
| 메소드 | 모든 접근 제어자, final, abstract, static |
| 변수 | 모든 접근 제어자, final, static |
| 지역변수 | final |

</div>

### 유의사항
- 클래스에 `abstract`와 `final` 동시에 사용 불가능
- 메소드에 `static`과 `abstract` 동시에 사용 불가능
- `abstract` 메소드의 접근 제어자로 `private` 불가능
