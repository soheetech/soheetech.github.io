---
layout: post
---


<h4>객체와 클래스</h4>
Java에서는 객체를 직접적으로 정의하여 다루지 않고 비슷한 유형의 객체들을 묶어 추상화시킨 클래스를 먼저 정의하고 클래스를 이용해 객체를 다루며 객체들 간의 상호작용으로 Java 프로그램이 동작함


<h5>추상화(Abstraction)</h5>
프로그래밍의 대상이 되는 사물을 표현하는 방식, 구체적인 모든 사실이 아니라 전형적이고 필요한 부분만을 발췌(⇒ 유연성 확보)하여 사물을 이해하고 표현하는 것.

추상화 예시
<table>
  <tr>
    <th colspan="2">Person</th>
  </tr>
  <tr>
    <td>정보(속성)</td>
    <td>- pNo : String<br />- name : String<br />- gender : char<br />...</td>
  </tr>
  <tr>
    <td rowspan="2">기능(행동)</td>
    <td>+ Person()</td>
  </tr>
  <tr>
    <td>+setXXX() : void<br />+ getXXX : 각 자료형</td>
  </tr>
</table>


<h5>객체(Object)</h5>
- 독립적으로 존재하며 각각 구분해서 인식 할 수 있는 개별 대상 하나하나를 표현한 것
- 유일하게 식별되는 존재로 어떠한 두 객체도 완전히 동일할 수는 없음
- 클래스의 실체, 클래스에 정의된 내용대로 new 연산자를 통해 메모리 영역에 생성/할당된 것(Object)

객체(Instance)의 할당
new 연산자와 생성자를 사용하여 객체 생성 시 Heap 메모리 영역에 서로 다른 자료형의 데이터가 연속으로 나열/할당된 객체 공간

```java
Student s = new Student();
```


<h5>지향(Oriented)</h5>
어떠한 것을 목표로 함<br /><br />

⇒ 객체 지향 : 독립적으로 각각 구분해서 인식할 수 있는 것을 목표로 함<br />
⇒ 객체 지향 언어 : 독립적으로 각각 구분해서 인식할 수 있는 것을 목표로 하는 코딩 방식

객체 지향 3+1대 특징
1. 캡슐화
2. 상속
3. 다형성
4. 추상화


<h5>클래스(class)</h5>
- Java 프로그램 구성의 기본 단위. 즉, Java 프로그램을 클래스들의 집합으로 볼 수 있음
- 객체를 만들기 위한 모형 또는 틀(설계도)
- 공통적인 특징을 가지는 객체들을 추상화하기 위한 수단
- 객체의 특성(속성, 기능)에 대한 정의를 한 것
- 객체의 상태는 필드(데이터)로 행위는 메소드로 구현됨
- 하나의 특정 클래스를 통해 만들어진 모든 객체는 같은 종류에 포함된다고 할 수 있음
- 객체는 특정 클래스의 인스턴스
- 클래스 작성 시 추상화, 캡슐화가 적용되어야 함
*기능 == 행동 == method =/= 함수(function)*<br />
*VO(value Object) : 값 저장용 객체를 만들기 위한 클래스를 모아두는 패키지*<br />
*Service : 특정 기능(비즈니스 로직)을 제공하는 클래스*

인스턴스화: 설계도 가지고 객체 만드는 것

```java
[접근제한자] [예약어] class 클래스명 {
  [접근제한자] [예약어] 자료형 변수명; // 속성값 설정
  [접근제한자] [예약어] 자료형 변수명; // 속성값 설정
  
  [접근제한자] 생성자명() {}
  
  [접근제한자] 반환명 메소드명(매개변수) {
    // 기능 정의
  }
}
```

클래스 등장 배경
변수 -> 배열 -> 구조체

클래스 접근제한자
<table>
  <tr>
    <th colspan="2">구분</th>
    <th>같은 패키지 내</th>
    <th>전체</th>
  </tr>
  <tr>
    <td>+</td>
    <td>public</td>
    <td>O</td>
    <td>O</td>
  </tr>
  <tr>
    <td>~</td>
    <td>(default)</td>
    <td>O</td>
    <td></td>
  </tr>
</table>
*[] : 생략가능, () : 무조건 생략*


- 필드(field) : =데이터, 멤버변수, 클래스가 표현하고자 하는 대상들이 공통적으로 가지는 상태값을 저장하는 변수
객체의 속성을 작성하는 클래스 내부 영역, Private String name;
	-> == 멤버 변수 : 메소드 밖에 작성된 변수
	
	 인스턴스 변수 : 필드에 작성되는 일반 변수 static 없는 필드
	
	 클래스 변수(== static 변수) : 필드에 static 예약어가 작성된 변수 public static double pi = 3.14;
	 why? 같은 클래스로 만들어진 객체가 값을 공유할 수 있기 때문에
	
  
```java
[접근제한자] [예약어] class 클래스명 {
  [접근제한자] [예약어] 자료형 변수명 [=초기값];
}

// 접근제한자 생략 시 (default)
// 캡슐화 원칙으로 private 사용
```

필드 접근제한자
<table>
  <tr>
    <th colspan="2">구분</th>
    <th>해당 클래스 내부</th>
    <th>같은 패키지 내</th>
    <th>후손 클래스 내</th>
    <th>전체</th>
  </tr>
  <tr>
    <td>+</td>
    <td>public</td>
    <td>O</td>
    <td>O</td>
    <td>O</td>
    <td>O</td>
  </tr>
  <tr>
    <td>#</td>
    <td>protected</td>
    <td>O</td>
    <td>O</td>
    <td>O</td>
    <td></td>
  </tr>
  <tr>
    <td>~</td>
    <td>(default)</td>
    <td>O</td>
    <td>O</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>-</td>
    <td>private</td>
    <td>O</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>

- 필드 예약어 : static
같은 타입의 여러 객체가 공유할 목적의 필드에 사용하며, 프로그램 시작시 정적 메모리(static) 영역에 자동 할당되는 멤버에 적용

```java
public class Academy {
  private static int temp1;
}
```
- 필드 예약어 : final
하나의 값만 계속 저장해야 하는 변수에 사용하는 예약어

```java
public class Academy {
	private final int TEMP1 = 100; // final 키워드가 붙은 필드명은 모두 대문자로 표기
	private int temp4;
}
```

클래스 초기화 블럭
- 인스턴스 블럭 ({})
  + 인스턴스 변수를 초기화 시키는 블럭, 객체 생성시마다 초기화
- static(클래스) 블럭 (static{})
  + static 필드를 초기화시키는 블럭으로 프로그램 시작 시 한번만 초기화

```java
[접근제한자] [예약어] class 클래스명 {
	[접근제한자] static 자료형 필드1 = 10;
	[접근제한자] 자료형 필드2 = 20 // 명시적 초기화;
	static { 필드1 = 30; }
	{ 필드2 = 40; }
}
```

필드 초기화 순서
- 클래스 변수
  + JVM 기본값 -> 명시적 초기값 -> 클래스 초기화 블록 초기값
- 인스턴스 변수
  + JVM 기본값 -> 명시적 초기값 -> 인스턴스 초기화 블록 초기값 -> 생성자를 통한 초기값



<h5>캡슐화(Encapsulation)</h5>
추상화를 통해 정리된 데이터(속성)들과 기능을 하나로 묶어 관리하는 기법<br />
클래스의 가장 중요한 목적인 데이터의 직접 접근제한(=정보 은닉 효과 발생)을 원칙으로 하여 클래스 외부에서 데이터의 직접적인 접근을 막고 대신 간접적으로 데이터에 접근할 수 있도록 메소드를 클래스 내부에 작성하는 방법

캡슐화 원칙
- 클래스의 멤버 변수에 대한 접근 권한은 private을 원칙으로 한다.
- 클래스의 멤버 변수에 대한 연산처리를 목적으로 하는 멤버 메소드는 클래스 내부에 작성한다.
- 멤버 메소드는 클래스 밖에서 접근할 수 있도록 public으로 설정한다.


<h5>상속(Inheritance)</h5>
- 상속은 부모 클래스와 자식 클래스 간의 관계
  + 클래스 A가 클래스 B로부터 B의 구성요소인 필드와 메소드를 물려받았을 때 클래스 A는 클래스 B를 상속함 또는 클래스 A는 클래스 B로부터 상속받음
- 가장 중요한 객체지향 개념의 하나로 기존 클래스를 이용해 새로운 클래스를 정의하는 방법
- 프로그램 구조화를 위한 좋은 방법
- 상속을 주는 클래스 : 슈퍼, 베이스, 기반, 상위 또는 부모 클래스
- 상속을 받는 클래스 : 서브, 파생, 하위 또는 자식 클래스
- 서브 클래스는 슈퍼 클래스의 모든 특성을 상속받으며 추가적으로 자신만의 필드와 메소드를 정의할 수 있음



생성자

객체가 new 연산자를 통해 Heap 메모리 영역에 할당될 때 객체 안에서 만들어지는 필드 초기화 + 생성 시 필요한 기능 수행 == 멤버변수(인스턴스 변수, 클래스 변수)
생성자는 일종의 메소드로 전달된 초기값을 받아서 객체의 필드에 기록

생성자 규칙
생성자의 선언은 메소드 선언과 유사하나 반환 값이 없으며 생성자명을 클래스명과 똑같이 지정해주어야 함

생성자 표현식

```java
[접근제한자] [예약어] class 클래스명 {
	[접근제한자] 클래스명() {}
	[접근제한자] 클래스명(매개변수) { (this.)필드명 = 매개변수; }
}
```

- 기본 생성자
작성하지 않은 경우, 클래스 사용 시 컴파일러가 자동으로 기본 생성자 생성
- 매개변수 생성자
  + 객체 생성 시 전달받은 값으로 객체를 초기화 하기 위해 사용
  + 매개변수 생성자 작성 시 컴파일러가 기본 생성자를 자동으로 생성해주지 않음
  + 상속에서 사용 시 반드시 기본 생성자를 작성
  + 오버로딩을 이용하여 작성

오버로딩: 한 클래스 내에 동일한 이름의 메소드를 여러 개 작성하는 기법
오버로딩 조건
- 같은 메소드 이름
- 다른 매개변수의 개수 또는 다른 매개변수 타입, 순서

this : 모든 인스턴스의 메소드에 숨겨진 채 존재하는 레퍼런스로 할당된 객체를 가리킴
함수 실행 시 전달되는 객체의 주소를 자동으로 받음
매개변수를 가지는 생성자에서 매개변수명이 필드명과 같은 경우 매개변수의 변수명이 우선이므로 this 객체를 이용하여 대입되는 변수가 필드라는 것을 구분해줌

this() : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용, 반드시 첫번째 줄에 


- 메소드(method) : =알고리즘, 필드에 저장되어 있는 상태값을 조회/변경하거나 상태와 관련된 특별한 동작을 수행하는데 사용함
수학의 함수와 비슷하며 호출을 통해 사용, 전달 값이 없는 상태로 호출을  하거나 어떤 값을 전달하여 호출을 하며 함수 내에 작성된 연산 수행
수행 후 반환 값 / 결과 값은 있거나 없을 수 있음

메소드 표현식

```java
[접근제한자] [예약어] 반환형 메소드명( [매개변수] ) {
	// 기능 정의
}
```

메소드 접근제한자
<table>
  <tr>
    <th colspan="2">구분</th>
    <th>클래스</th>
    <th>패키지</th>
    <th>자손 클래스</th>
    <th>전체</th>
  </tr>
  <tr>
    <td>+</td>
    <td>public</td>
    <td>O</td>
    <td>O</td>
    <td>O</td>
    <td>O</td>
  </tr>
  <tr>
    <td>#</td>
    <td>protected</td>
    <td>O</td>
    <td>O</td>
    <td>O</td>
    <td></td>
  </tr>
  <tr>
    <td>~</td>
    <td>(default)</td>
    <td>O</td>
    <td>O</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>-</td>
    <td>private</td>
    <td>O</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>



<h5>다형성(Polymorphism)</h5>







